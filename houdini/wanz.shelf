<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <shelfSet name="shelf_set_3" label="New Shelf Set">
    <memberToolshelf name="shelf_1"/>
    <memberToolshelf name="RenderMan23"/>
    <memberToolshelf name="labs_toolset"/>
    <memberToolshelf name="qLib"/>
    <memberToolshelf name="MOPs"/>
    <memberToolshelf name="MOPs_Tools"/>
    <memberToolshelf name="qLib_update"/>
  </shelfSet>

  <toolshelf name="labs_toolset" label="SideFX Labs">
    <memberTool name="update_toolset"/>
  </toolshelf>

  <toolshelf name="MOPs_Tools" label="MOPs Tools">
    <memberTool name="MOPs_distribute_on_spline"/>
    <memberTool name="MOPs_snap_centroid_to_spline"/>
    <memberTool name="MOPs_Pivot"/>
  </toolshelf>

  <toolshelf name="MOPs" label="MOPs">
    <memberTool name="MOPS_convert_point_instances"/>
    <memberTool name="MOPS_Disable_Preview"/>
    <memberTool name="MOPS_Update"/>
    <memberTool name="collapse_hdas"/>
    <memberTool name="expand_hdas"/>
    <memberTool name="wiki"/>
    <memberTool name="mops_donate"/>
    <memberTool name="mops_feedback"/>
  </toolshelf>

  <toolshelf name="qLib_update" label="qLib-update">
    <memberTool name="qLib::qLibUpdate"/>
  </toolshelf>

  <toolshelf name="qLib" label="qLib">
    <memberTool name="qLib::AccessShotNode"/>
    <memberTool name="qLib::ToggleViewportBackgroundColor"/>
    <memberTool name="qLib::camera_dolly_zoom_ql"/>
    <memberTool name="qLib::ToggleViewportTemplates"/>
    <memberTool name="qLib::ToggleViewportGuides"/>
    <memberTool name="qLib::AttribDisplayMarkers"/>
    <memberTool name="qLib::ReferenceCopy"/>
    <memberTool name="qLib::ToggleTimeDependencyDisplay"/>
    <memberTool name="qLib::ColorByAuthor"/>
    <memberTool name="qLib::ToggleIntegerFrames"/>
    <memberTool name="qLib::FlushCaches"/>
    <memberTool name="qLib::CrashRecovery"/>
  </toolshelf>

  <toolshelf name="RenderMan23" label="RenderMan 23">
    <memberTool name="rman_ipron"/>
    <memberTool name="rman_iproff"/>
    <memberTool name="rman_openit"/>
    <memberTool name="rman_ris23"/>
    <memberTool name="rman_spareparms"/>
    <memberTool name="rman_holdout"/>
    <memberTool name="rman_pxrsurface"/>
    <memberTool name="rman_pxrrectlight"/>
    <memberTool name="rman_pxrdisklight"/>
    <memberTool name="rman_pxrspherelight"/>
    <memberTool name="rman_pxrcylinderlight"/>
    <memberTool name="rman_pxrmeshlight"/>
    <memberTool name="rman_pxrvolumelight"/>
    <memberTool name="rman_pxrdomelight"/>
    <memberTool name="rman_pxrportallight"/>
    <memberTool name="rman_pxrenvdaylight"/>
    <memberTool name="rman_pxrdistantlight"/>
    <memberTool name="rman_pxraovlight"/>
  </toolshelf>

  <toolshelf name="shelf_1" label="New Shelf"/>

  <tool name="update_toolset" label="Update Toolset" icon="CHOP_joystick">
    <helpURL>tool:update_toolset</helpURL>
    <script scriptType="python"><![CDATA[import os
import shutil
import contextlib
import json
import zipfile
import platform
import hou
import urllib2
import ssl
import glob


from hutil.Qt.QtCore import *
from hutil.Qt.QtGui import *
from hutil.Qt.QtWidgets import *

########################################################################################################################
# GLOBAL VARIABLES #####################################################################################################

REPO_URL = 'https://api.github.com/repos/sideeffects/SideFXLabs'

# store the major and minor version of Houdini (aka XX.YY)
APP_VERSION = ".".join(map(str, hou.applicationVersion()[:2]))

SETTINGS_FILE = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "packages", "SideFXLabs.json")
HOUDINI_ENV = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "houdini.env")

LOCAL_ZIPS = glob.glob(os.path.normpath(os.path.join(hou.getenv("HH"), "public", "SideFX_Labs_Houdini_*.zip")))
LOCAL_TOOLSET_ZIP = LOCAL_ZIPS[0] if LOCAL_ZIPS else None
LOCAL_TOOLSET_VERSION = LOCAL_TOOLSET_ZIP.split('_')[-1][-7:-4] + " (local)" if LOCAL_TOOLSET_ZIP else None

HOU_TEMP_PATH = os.path.normpath(os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "SideFXLabs"))
ONLINE_ZIP_DICT = {}


# UPDATE DIALOG ########################################################################################################
class UpdateDialog(QDialog):
    def __init__(self, parent, updater_object):
        super(UpdateDialog, self).__init__(parent)
        self.setWindowTitle("SideFX Labs")
        self.updater_object = updater_object

        self.current_version = None

        if self.updater_object.current_version:
            self.current_version = self.updater_object.current_version

        self.build_ui()

    def build_ui(self):
        installed_group = QGroupBox("Installed Version")
        change_group = QGroupBox("Change To")
        spacer = QLabel("")

        # Current Version
        current_version_layout = QHBoxLayout()
        current_version_lbl = QLabel("Release: ")
        current_version = self.current_version
        if not current_version:
            current_version = "None"

        current_version_value_lbl = QLabel(current_version)

        current_version_layout.addWidget(current_version_lbl)
        current_version_layout.addWidget(current_version_value_lbl)

        installedgroup_layout = QVBoxLayout(installed_group)

        installedgroup_layout.addLayout(current_version_layout)

        # Update
        version_layout = QHBoxLayout()
        update_version_label = QLabel("Release:")

        self.version_combo = QComboBox(self)
        for release in self.updater_object.production_releases[:10]:
            self.version_combo.addItem(release)

        self.production_builds_check = QCheckBox("Production Builds Only")
        self.production_builds_check.setChecked(True)
        self.production_builds_check.stateChanged.connect(self.on_production_check)

        version_layout.addWidget(update_version_label)
        version_layout.addWidget(self.version_combo)
        version_layout.addWidget(self.production_builds_check)

        changedgroup_layout = QVBoxLayout(change_group)
        changedgroup_layout.addLayout(version_layout)
        self.button = QPushButton("Update")
        self.uninstallButton = QPushButton("Uninstall")

        self.button.clicked.connect(self.on_updatebtn_press)
        self.uninstallButton.clicked.connect(self.on_uninstallbtn_press)
        layout = QVBoxLayout()

        layout.addWidget(installed_group)
        layout.addWidget(change_group)

        layout.addWidget(spacer)


        if hou.getenv("SIDEFXLABS_ADMIN_UPDATES", "0") == "1":
            warning_layout = QHBoxLayout()
            admin_warninglabel = QLabel(self)
            admin_warninglabel.setText("The system administrator has disabled updating on this machine.\nPlease contact the administrator for any changes")
            admin_warninglabel.setStyleSheet('color: red')
            warning_layout.addWidget(admin_warninglabel)
            layout.addLayout(warning_layout)
            self.button.setEnabled(False)
            self.uninstallButton.setEnabled(False)

        layout.addWidget(self.button)
        layout.addWidget(self.uninstallButton)
        self.setLayout(layout)

    def on_production_check(self, state=None):
        self.version_combo.clear()
        if self.production_builds_check.isChecked():
            for release in self.updater_object.production_releases[:10]:
                self.version_combo.addItem(release)
        else:
            for release in self.updater_object.releases[:10]:
                self.version_combo.addItem(release)

    def on_updatebtn_press(self):
        version = self.version_combo.currentText()
        if version != "":
            if LOCAL_TOOLSET_VERSION != version:
                self.updater_object.on_dialog_close(version, "change")
            else:
                self.updater_object.on_dialog_close(LOCAL_TOOLSET_VERSION, "change", local_zip=1)
        self.close()

    def on_uninstallbtn_press(self):
        version = self.current_version
        if version != None:
            self.updater_object.on_dialog_close(version, "uninstall")
        self.close()


# UPDATER ##############################################################################################################
class SideFXLabsUpdater(object):
    """
        Main updater object, gets called with the shelf button press


    """

    def __init__(self):

        # Store Releases and Production Releases
        self.releases = []
        self.production_releases = []

        self.desired_version = None

        # bail if not allowed in pipelines
        disabling_message = os.getenv("SIDEFXLABS_NOINSTALL_MESSAGE")
        if disabling_message:
            hou.ui.displayMessage(disabling_message)
            return

        
        self.load_settings()
        self.get_releases()   
        self.show_dialog()

        self.clean_old_installs()


    def clean_old_installs(self):
        if not os.path.isdir(HOU_TEMP_PATH):
            return
        for item in os.listdir(HOU_TEMP_PATH):
            if os.path.isdir(os.path.join(HOU_TEMP_PATH, item)):
                if item != self.current_version:
                    shutil.rmtree(os.path.join(HOU_TEMP_PATH, item), ignore_errors=True)


    def get_releases(self):

        # Attempt to download things from github
        try:
            with contextlib.closing(urllib2.urlopen(urllib2.Request(REPO_URL + "/releases"), context=ssl._create_unverified_context())) as response:
                data = response.read()
                if data == "":
                    raise ValueError("Unable to get the release list")
        except:
            if LOCAL_TOOLSET_VERSION != None:
                self.production_releases.append(LOCAL_TOOLSET_VERSION)
                self.releases.append(LOCAL_TOOLSET_VERSION)
            return

        if LOCAL_TOOLSET_VERSION != None:
            self.production_releases.append(LOCAL_TOOLSET_VERSION)


        # Parse the data and filter out versions we don't care about
        j_data = json.loads(data.decode('utf-8'))
        for release in j_data:

            contained_assets = release["assets"]
            for asset in contained_assets:

                build_version = asset["name"][20:-4]

                if build_version[:4] == str(APP_VERSION) and self.current_version != build_version[-3:]:

                    if release["prerelease"]:
                        self.releases.append(build_version[-3:])
                    else:
                        self.production_releases.append(build_version[-3:])

                    ONLINE_ZIP_DICT[build_version[-3:]] = asset["browser_download_url"]
        

    def show_dialog(self):
        dialog = UpdateDialog(hou.ui.mainQtWindow(), self)
        dialog.show()

    def download_url(self, url):
        """
            Download the zip file from github
        :param url:
        :return:
        """

        filename = os.path.basename(url)
        local_path = os.path.join(HOU_TEMP_PATH, filename)

        if not os.path.exists(os.path.dirname(local_path)):
            os.makedirs(os.path.dirname(local_path))

        try:
            zipfile = urllib2.urlopen(url, context=ssl._create_unverified_context())
            with open(local_path, 'wb') as output:
                output.write(zipfile.read())
        except:
            raise ValueError("Unable to download the package file :" + url)
            return

        return local_path

    def unzip_file(self, zip_file, destination_path):
        zipf = zipfile.ZipFile(zip_file, 'r', zipfile.ZIP_DEFLATED)
        zipf.extractall(destination_path)

    def load_settings(self):
        try:
            with open(SETTINGS_FILE, 'r') as fp:
                settings = json.load(fp)
                self.current_version = settings["env"][0]["sidefxlabs_current_version"]
        except:
            self.current_version = None


    def show_success_dialog(self, mode):        
        message = ""
        
        if mode == "change":
            message = "SideFX Labs updated successfully"
            message += "\nPlease Restart Houdini to load all of the new tools"
        
        elif mode == "uninstall":
            message = "SideFX Labs uninstalled successfully"
            message += "\nPlease restart Houdini for changes to take effect"
        
        elif mode == "localbuild":
            message = "SideFX Labs installed successfully"
            message += "\nA local copy has been installed. If you wish to update to a newer (online) version, update again"
            message += "\nPlease restart Houdini to load all of the new tools"

        hou.ui.displayMessage(message, title="Success")
        
    def on_dialog_close(self, version, mode, local_zip=0):
        """ Call back from the Updater Dialog """
        self.desired_version = version

        # Create Packages Folder if non-existent
        packages_dir = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "packages")
        if not os.path.exists(packages_dir):
            os.makedirs(packages_dir)

        
        if mode == "change":

            if local_zip == 0:
                download_url = ONLINE_ZIP_DICT[version]
                local_path = self.download_url(download_url)
            else:
                local_path = LOCAL_TOOLSET_ZIP

            if not os.path.isdir(os.path.join(HOU_TEMP_PATH, version)):
                self.unzip_file(local_path, os.path.join(HOU_TEMP_PATH, version))

            if local_zip == 0:
                os.remove(local_path)

            SIDEFXLABSJSON = {}
            SIDEFXLABSJSON['path'] = os.path.join(HOU_TEMP_PATH, version).replace("\\", "/")
            SIDEFXLABSJSON['env'] = [ {'sidefxlabs_current_version' : version },
                                   {
                                        "PATH" : {
                                            "value" : [os.path.join(HOU_TEMP_PATH, version, "bin").replace("\\", "/")],
                                            "method" : "prepend"
                                        }
                                   }
                                 ]

            JSON = json.dumps(SIDEFXLABSJSON, indent=4)
            f = open(SETTINGS_FILE,"w")
            f.write(JSON)
            f.close()

            if local_zip == 0:
                self.show_success_dialog("change")
            else:
                self.show_success_dialog("localbuild")
            self.current_version = version

        elif mode == "uninstall":

            # Delete Installed Files
            removedir = os.path.join(HOU_TEMP_PATH, version)
            if os.path.exists(removedir):
                shutil.rmtree(removedir, ignore_errors=True)

            if os.path.isfile(SETTINGS_FILE):
                os.remove(SETTINGS_FILE)

            self.show_success_dialog("uninstall")

SideFXLabsUpdater()]]></script>
  </tool>

  <tool name="MOPS_convert_point_instances" label="MOPs to Point Instances" icon="opdef:MOPS::Sop/Instancer::1.1?mops_instancing.svg">
    <helpText><![CDATA[= MOPs to Point Instances = 

"""Converts a MOPs network into Fast Point Instances, for use with other renderers such as Redshift. """

This shelf tool converts one or more SOP networks with MOPs in them into individual object containers for each instance, along with an Instancer object that references them.
The generated <network_name>_MOPS_INSTANCE_RENDER Instance object is the resulting renderable object. The generated object containers are placed inside the subnetwork "MOPS_INSTANCES."

If you modify your instance object paths or indexes, you will likely need to delete the automatically generated MOPS_INSTANCE_RENDER Instance container before using this tool again.]]></helpText>
    <toolMenuContext name="viewer">
      <contextNetType>OBJ</contextNetType>
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <script scriptType="python"><![CDATA["""
1.) get all s@objpath paths
2.) create object container subnet 'INSTANCES'
3.) create object container for each path found
4.) object merge original (absolute) path of each path found into containers
5.) create originalSOP_INSTANCER object container
6.) append extract attributes and output null to original MOP network
6.) object merge output of original MOP network into originalSOP_INSTANCER and delete prims
7.) set s@instance attribute to point to generated containers
"""
import toolutils
import re

prompt = toolutils.selectionPrompt(hou.sopNodeTypeCategory())
scene_viewer = toolutils.sceneViewer()
sel = scene_viewer.selectObjects(prompt)
INSTANCE_DICT = dict()
nodes_to_align = list()

# collect instance paths
for i in sel:
    INSTANCE_DICT[i.path()] = dict()
    INSTANCE_DICT[i.path()]['paths'] = dict()

    out = i.displayNode()
    path_attr = out.geometry().findPointAttrib('objpath')
    if not path_attr:
        hou.ui.displayMessage('SOP node {} does not have "objpath" point attribute!'.format(out.name()),
                              severity=hou.severityType.Error)
        continue
    index_attr = out.geometry().findPointAttrib('mops_index')
    if not index_attr:
        hou.ui.displayMessage('SOP node {} does not have "mops_index" point attribute!'.format(out.name()),
                              severity=hou.severityType.Error)
        continue
    # since i'm shit at iterating over geometry, if there's a material override,
    # let's just promote that to a point attrib so we can do it all at once.
    mat_overrides = False
    temp_promote = None
    if out.geometry().findPrimAttrib('shop_materialpath'):
        mat_overrides = True
        temp_promote = i.createNode('attribpromote')
        temp_promote.setFirstInput(out)
        temp_promote.parm('inclass').set('primitive')
        temp_promote.parm('inname').set('shop_materialpath')
        out = temp_promote

    # now get paths information.
    for pt in out.geometry().iterPoints():
        path = pt.attribValue('objpath')
        index = str(pt.attribValue('mops_index'))
        if path not in INSTANCE_DICT[i.path()]['paths'].keys():
            INSTANCE_DICT[i.path()]['paths'][path] = dict()
            INSTANCE_DICT[i.path()]['paths'][path]['index'] = index
            INSTANCE_DICT[i.path()]['paths'][path]['material'] = None
            if mat_overrides:
                mat = pt.attribValue('shop_materialpath')
                INSTANCE_DICT[i.path()]['paths'][path]['material'] = mat

    if temp_promote:
        temp_promote.destroy()

# print(INSTANCE_DICT)



# generate instance object containers
for network in INSTANCE_DICT:

    # get or build instances container subnet
    instances_container = hou.node('/obj/{}_MOPS_INSTANCES'.format(network.split('/')[-1]))
    if instances_container is None:
        instances_container = hou.node('/obj').createNode('subnet', '{}_MOPS_INSTANCES'.format(network.split('/')[-1]))
        instances_container.setDisplayFlag(False)
    nodes_to_align.append(instances_container)

    for i, v in INSTANCE_DICT[network]['paths'].iteritems():
        # name = i.replace('/', '_')
        name = re.sub('[^\w_ ]', '_', i)
        instanced_node = instances_container.node(name)
        if instanced_node is None:
            instanced_node = instances_container.createNode('geo', name)
            if instanced_node.node('file1') is not None:
                instanced_node.node('file1').destroy()
            load_node = None
            if i.endswith(".abc"):
                load_node = instanced_node.createNode('alembic')
                load_node.parm('fileName').set(i)
            else:
                load_node = instanced_node.createNode('file')
                load_node.parm('file').set(i)
            
            #merge = instanced_node.createNode('object_merge')
            #merge.parm('xformtype').set('local')
            #merge.parm('objpath1').set(i)
            load_node.setRenderFlag(True)
            load_node.setDisplayFlag(True)
            # set material if one exists
            if v['material'] is not None:
                instanced_node.parm('shop_materialpath').set(v['material'])
        # nodes_to_align.append(instanced_node)

for i in sel:
    # append output null to MOPS network(s)
    null = i.node('MOPS_OUT')
    if null is None:
        null = i.createNode('null', 'MOPS_OUT')
        out = i.displayNode()
        null.setFirstInput(out)

    # generate point instancer
    name = '/obj/{}_MOPS_INSTANCE_RENDER'.format(i.name())
    instancer = hou.node(name)
    if instancer is None:
        instancer = hou.node('/obj').createNode('instance', name.split('/')[-1])
        instancer.parm('ptinstance').set('fast')
        instancer.node('add').destroy()
        hou.node('/obj').layoutChildren([instancer])
    nodes_to_align.append(instancer)

    # merge in mops output and convert to points
    merge = instancer.node('merge_in_MOPS')
    if merge is None:
        merge = instancer.createNode('object_merge', 'merge_in_MOPS')
        merge.parm('objpath1').set(null.path())
    extract = instancer.node('extract_attributes')
    if extract is None:
        extract = instancer.createNode('MOPS::Extract_Attributes::1.0', 'extract_attributes')
        extract.setFirstInput(merge)
    add = instancer.node('remove_prims')
    if add is None:
        add = instancer.createNode('add', 'remove_prims')
        add.parm('keep').set(True)
        add.setFirstInput(extract)

    # point wrangle will map original instancer objpath attrs to new instance containers
    setInstance = instancer.node('set_instance_path')
    if setInstance is None:
        setInstance = instancer.createNode('attribwrangle', 'set_instance_path')
        setInstance.setFirstInput(add)
        setInstance.setDisplayFlag(True)
        setInstance.setRenderFlag(True)

    # generate instancing string.
    instances_container = hou.node('/obj/{}_MOPS_INSTANCES'.format(i.name()))
    instance_snippet = ""
    for k, v in INSTANCE_DICT[i.path()]['paths'].iteritems():
        name = re.sub('[^\w_ ]', '_', k)
        container = instances_container.node(name)
        instance_snippet += 'if(i@mops_index == {}) s@instance = "{}";\n'.format(v['index'], container.path())
    setInstance.parm('snippet').set(instance_snippet)

    # cleanup
    instancer.layoutChildren()
    i.setDisplayFlag(False)
    instances_container.layoutChildren()
    hou.node('/obj').layoutChildren(nodes_to_align)]]></script>
  </tool>

  <tool name="MOPs_snap_centroid_to_spline" label="MOPs Move Along Spline (Snap Group)" icon="opdef:MOPS::Sop/move_along_spline::1.4?mops_modifier_02.svg">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>MOPs/Modifiers</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

# generate a MOPs Move Along Spline modifier, enable Snap to Centroid,
# set the starting attachment position to 0, and set Offset to 1.

node = soptoolutils.genericTool(kwargs, "MOPS::move_along_spline::1.4", force_filter=True)
node.parm('do_snap').set(1)
node.parm('maintain_offset').set(1.0)
node.parm('attach_mode').set(1)
node.parm('attach_attr').set("")]]></script>
  </tool>

  <tool name="MOPs_distribute_on_spline" label="MOPs Move Along Spline (Distribute)" icon="opdef:MOPS::Sop/move_along_spline::1.4?mops_modifier_02.svg">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>MOPs/Modifiers</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

# generate a MOPs Move Along Spline modifier, then set it to distribute
# everything onto the spline.

node = soptoolutils.genericTool(kwargs, 'MOPS::move_along_spline::1.4', force_filter=True)
node.parm('attach_mode').set(2)
node.parm('curve_select_mode').set(1)]]></script>
  </tool>

  <tool name="MOPs_Pivot" label="MOPs Pivot" icon="opdef:MOPS::Sop/Align::1.0?mops_modifier_02.svg">
    <toolMenuContext name="network">
      <contextNetType>SOP</contextNetType>
    </toolMenuContext>
    <toolSubmenu>MOPs/Modifiers</toolSubmenu>
    <script scriptType="python"><![CDATA[import soptoolutils

# generate a MOPs Move Along Spline modifier, enable Snap to Centroid,
# set the starting attachment position to 0, and set Offset to 1.

node = soptoolutils.genericTool(kwargs, "MOPS::Align::1.0", force_filter=True)]]></script>
  </tool>

  <tool name="qLib::AccessShotNode" label="::shot::" icon="NETWORKS_scene">
    <helpText><![CDATA[#icon: NETWORKS/scene
#context: obj
#type: tool

= Access: Shot Node qL =

*version 1*

"""Opens a floating parameter panel for scene Shot qL node(s).
---
LMB: All Shot and Environment nodes.
Shift-LMB: Only "active" Shot(s) (visible/selectable).
Alt-LMB: Environment nodes only.
"""

@bugs Limitations

- ...


@relnotes Release Notes

_version 1_ ---

2014-10-12:
    - First version.
]]></helpText>
    <script scriptType="python"><![CDATA[import toolutils


def show_parms(ops, title="Parameters", kwargs=None):
    """."""
    PT = hou.paneTabType.Parm
    P = None
    t = None

    for op in ops:
        if P is None:
            P = hou.ui.curDesktop().createFloatingPanel(PT)
            P.setName(title)
            t = P.panes()[0].tabs()[0]
        else:
            t = P.panes()[0].createTab(PT)

        if t:
            t.setPin(True)
            t.setCurrentNode(op)

    return P



ctrl = kwargs['ctrlclick']
shift = kwargs['shiftclick']
alt = kwargs['altclick']

is_shot = lambda n: 'qLib::shot_ql' in n.type().name()
is_env = lambda n: 'qLib::environment_ql' in n.type().name()

# find all Shot qL OPs first
#
shots = [ c for c in hou.node('/').allSubChildren()
    if is_shot(c) or is_env(c) ]

if shift or ctrl:
    shots = [ n for n in shots if n.isSelectableInViewport() or n.isDisplayFlagSet() ]

if alt:
    shots = [ n for n in shots if is_env(n) ]

shots = sorted(shots,
    key=lambda n: '%s %d %d %s' % (n.type().name(),
        n.isSelectableInViewport(),
        n.isDisplayFlagSet(),
        n.name(), )
    )

show_parms(shots, title="Scene Global(s)", kwargs=kwargs)

]]></script>
  </tool>

  <tool name="MOPS_Disable_Preview" label="Disable Falloff Previews" icon="opdef:MOPS::Sop/Plain_Falloff::1.0?mops_falloff_04.svg">
    <helpText><![CDATA[= Disable Falloff Previews =

""" Disables all falloff previews in the current SOP chain. """

Falloff previews are currently a destructive operation, as they overwrite the MOPs primitives with colored sprites.
This tool disables falloff previews for all nodes in the current SOP hierarchy.]]></helpText>
    <script scriptType="python"><![CDATA[import toolutils

# get current location
pane = toolutils.activePane(kwargs)
node = pane.pwd()

# recursively get all child nodes
if node:
    children = node.allSubChildren()
    if children:
        for i in children:
            if i.parm('do_preview') is not None:
                try:
                    i.parm('do_preview').set(0)
                except:
                    pass

]]></script>
  </tool>

  <tool name="MOPS_Update" label="MOPs Updater" icon="opdef:MOPS::Sop/Instancer::1.1?mops_update.svg">
    <helpText><![CDATA[= MOPs Updater = 

""" Automatically download and install any Experimental or Stable release of MOPs. """

This tool uses the Github API to automatically look for newer version of MOPs. You can
select either the Experimental or Stable branches, then use the dropdown to choose which
version you want to install. The most recent version is always the default entry.

Installing an update will overwrite your current MOPs installation.

If you select "Auto-Update houdini.env", the patcher will try to update your houdini.env
file to meet the latest installation standard for MOPs (appending to HOUDINI_PATH rather
than HOUDINI_OTLSCAN_PATH, etc). This is unnecessary if you've already used the current
recommended installation process from README.MD.

If you enable "Share anonymous MOPs data", you will send us completely anonymous metrics
data describing what MOPs nodes you're most frequently using. If you enable this and want to
disable it later, you can edit your houdini.env file and set MOPS_ALLOW_ANALYTICS to 0.]]></helpText>
    <script scriptType="python"><![CDATA[import mops_updater
# launch ui
win = mops_updater.MOPsUpdateWindow(hou.ui.mainQtWindow())]]></script>
  </tool>

  <tool name="collapse_hdas" label="Collapse HDAs" icon="opdef:MOPS::Sop/Instancer::1.1?mops_collapse.svg">
    <helpText><![CDATA[= Collapse HDAs = 

""" Compress the MOPs toolkit into packed format. """

MOPs is distributed as expanded HDAs, meaning they are described in plain text. This makes 
updating code on Github much more straightforward, but it creates a lot of files. This can be
problematic if you're running MOPs on a network server. Running this shelf tool will convert
all MOPs HDAs into packed format, which will make them load much faster over a network connection.
]]></helpText>
    <script scriptType="python"><![CDATA[import mops_tools
import os
import traceback

def do_collapse():
    if hou.getenv('MOPS') is None:
        hou.ui.displayMessage('$MOPS environment variable not found! Aborting.')
        return
        
    hda_path = os.path.join(hou.getenv('MOPS'), 'otls')
    try:
        mops_tools.collapse_hdas(hda_path)
        hou.ui.displayMessage('MOPS HDAs collapsed succesfully!')
    except:
        hou.ui.displayMessage('Error collapsing HDAs: {}'.format(traceback.format_exc()), severity=hou.severityType.Error)
        
do_collapse()]]></script>
  </tool>

  <tool name="expand_hdas" label="Expand HDAs" icon="opdef:MOPS::Sop/Instancer::1.1?mops_expand.svg">
    <helpText><![CDATA[= Expand HDAs =

""" Expand the MOPs HDAs into unpacked (plaintext) format. """

MOPs is distributed as expanded HDAs, meaning they are described in plain text. This makes 
updating code on Github much more straightforward, but it creates a lot of files. This can be
problematic if you're running MOPs on a network server. 

If you've used the Collapse HDAs tool to convert MOPs into packed format and you need to convert back for 
some reason, this shelf tool will expand all MOPs HDAs into their original format.]]></helpText>
    <script scriptType="python"><![CDATA[import mops_tools
import os
import traceback

def do_expand():
    if hou.getenv('MOPS') is None:
        hou.ui.displayMessage('$MOPS environment variable not found! Aborting.')
        return
        
    hda_path = os.path.join(hou.getenv('MOPS'), 'otls')
    try:
        mops_tools.expand_hdas(hda_path)
        hou.ui.displayMessage('MOPS HDAs expanded succesfully!')
    except:
        hou.ui.displayMessage('Error expanding HDAs: {}'.format(traceback.format_exc()), severity=hou.severityType.Error)
        
do_expand()]]></script>
  </tool>

  <tool name="wiki" label="MOPs Wiki" icon="opdef:MOPS::Sop/Instancer::1.1?mops_wiki.svg">
    <helpText><![CDATA[= MOPs Wiki =

""" Open the default web browser to the MOPs Wiki page on Github. """

:note: 
    The MOPs Wiki is a work in progress! For complete documentation on a MOPs node, use the Help function in Houdini.
    
The MOPs Wiki on Github is a high-level overview of the MOPs installation process, overall design and concepts,
and a quick primer on most of the nodes. It's not meant to be a replacement for the documentation embedded in
each HDA's Help section. Use it as a reference when looking for a specific effect you're trying to create.

This button opens the default web browser and points it to the wiki homepage.]]></helpText>
    <script scriptType="python"><![CDATA[import webbrowser
url = 'https://github.com/toadstorm/MOPS/wiki'
webbrowser.open(url)]]></script>
  </tool>

  <tool name="mops_feedback" label="Share Feedback" icon="opdef:MOPS::Sop/Instancer::1.1?mops_feedback.svg">
    <helpText><![CDATA[= Share Feedback = 

""" Open a web browser to display our contact form. """

We really value feedback, questions, concerns, or just general opinions about MOPs. While
we would encourage you to visit [our forums|https://forum.motionoperators.com] to post bug 
reports or questions that could help other people, if you'd like to contact us privately,
we have a handy form to fill out. You can also email us at [info@motionoperators.com|mailto:info@motionoperators.com].

Thanks for using MOPs!
Moritz and Henry]]></helpText>
    <script scriptType="python"><![CDATA[import webbrowser
url = 'https://www.motionoperators.com/contact'

webbrowser.open(url)]]></script>
  </tool>

  <tool name="mops_donate" label="Donate" icon="opdef:MOPS::Sop/Instancer::1.1?mops_donate.svg">
    <helpText><![CDATA[= Donate to MOPs = 

""" Open the default browser to the MOPs donation page. """

The core MOPs tools are and will always be free and open source. While we may eventually release paid add-ons
to MOPs, they will only exist as a complement to the core tools, not a replacement.

Please consider donating to our cause, because we don't get paid to do this and we need to pay for our hosting!]]></helpText>
    <script scriptType="python"><![CDATA[import webbrowser
# url = 'https://secure.squarespace.com/checkout/donate?donatePageId=5bbd25fce5e5f0018b1fe49d'
url = 'https://www.paypal.com/donate/?token=uwTeGWGBR8X1p_KRBIKaAf2X3L_Hjd5nbmXXPqPmSE7NQsJPtighln8lVfmHXoSNy6JU5W&country.x=US&locale.x=US'
webbrowser.open(url)]]></script>
  </tool>

  <tool name="qLib::qLibUpdate" label="qLib Update" icon="DESKTOP_installer">
    <script scriptType="python"><![CDATA[import os
import shutil
import contextlib
import json
import zipfile
import platform
import hou
import urllib2
import ssl


from hutil.Qt.QtCore import *
from hutil.Qt.QtGui import *
from hutil.Qt.QtWidgets import *

########################################################################################################################
# GLOBAL VARIABLES #####################################################################################################

REPO_URL = 'https://api.github.com/repos/qLab/qLib'
REPO_DL_URL = 'https://github.com/qLab/qLib/archive'

# store the major and minor version of Houdini (aka 16.5)
APP_VERSION = ".".join(map(str, hou.applicationVersion()[:2]))

SETTINGS_FILE = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "qlib.json")
HOUDINI_ENV = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "houdini.env")

if platform.system() == "Windows":
    HOU_TEMP_PATH = os.path.join(os.getenv("APPDATA"), "SideFX", "qLib")
    HOU_TEMP_PATH_STR = "$APPDATA\\SideFX\\GameDevToolset"
else:
    HOU_TEMP_PATH = os.path.join(os.getenv("HOUDINI_USER_PREF_DIR"), "qLib")
    HOU_TEMP_PATH_STR = HOU_TEMP_PATH


# UPDATE DIALOG ########################################################################################################
class UpdateDialog(QDialog):
    def __init__(self, parent, updater_object):
        super(UpdateDialog, self).__init__(parent)
        self.setWindowTitle("qLib")
        self.updater_object = updater_object

        self.current_version = None

        if self.updater_object.current_version:
            self.current_version = self.updater_object.current_version

        self.build_ui()

    def build_ui(self):
        installed_group = QGroupBox("Installed Version")
        change_group = QGroupBox("Change To")
        spacer = QLabel("")

        # Current Version
        current_version_layout = QHBoxLayout()
        current_version_lbl = QLabel("Release: ")
        current_version = self.current_version
        if not current_version:
            current_version = "Unknown"

        current_version_value_lbl = QLabel(current_version)

        current_version_layout.addWidget(current_version_lbl)
        current_version_layout.addWidget(current_version_value_lbl)

        installedgroup_layout = QVBoxLayout(installed_group)

        installedgroup_layout.addLayout(current_version_layout)

        # Update
        version_layout = QHBoxLayout()
        update_version_label = QLabel("Release:")

        self.version_combo = QComboBox(self)
        for release in self.updater_object.production_releases[:10]:
            self.version_combo.addItem(release)

        self.production_builds_check = QCheckBox("Production Builds Only")
        self.production_builds_check.setChecked(True)
        self.production_builds_check.stateChanged.connect(self.on_production_check)

        version_layout.addWidget(update_version_label)
        version_layout.addWidget(self.version_combo)
        version_layout.addWidget(self.production_builds_check)

        changedgroup_layout = QVBoxLayout(change_group)

        changedgroup_layout.addLayout(version_layout)

        self.button = QPushButton("Update")
        self.uninstallButton = QPushButton("Uninstall")

        self.button.clicked.connect(self.on_updatebtn_press)
        self.uninstallButton.clicked.connect(self.on_uninstallbtn_press)
        layout = QVBoxLayout()

        layout.addWidget(installed_group)
        layout.addWidget(change_group)

        layout.addWidget(spacer)
        layout.addWidget(self.button)
        layout.addWidget(self.uninstallButton)
        self.setLayout(layout)

    def on_production_check(self, state=None):
        self.version_combo.clear()
        if self.production_builds_check.isChecked():
            for release in self.updater_object.production_releases[:10]:
                self.version_combo.addItem(release)
        else:
            for release in self.updater_object.releases[:10]:
                self.version_combo.addItem(release)

    def on_updatebtn_press(self):
        version = self.version_combo.currentText()
        self.updater_object.on_dialog_close(version, "change")
        self.close()

    def on_uninstallbtn_press(self):
        version = self.version_combo.currentText()
        self.updater_object.on_dialog_close(version, "uninstall")
        self.close()


# UPDATER ##############################################################################################################
class qLibUpdater(object):
    """
        Main updater object, gets called with the shelf button press


    """

    def __init__(self):

        # Store Releases and Production Releases
        self.releases = []
        self.production_releases = []

        self.desired_version = None

        # bail if not allowed in pipelines
        disabling_message = os.getenv("QLIB_NOINSTALL_MESSAGE")
        if disabling_message:
            hou.ui.displayMessage(disabling_message)
            return

        # TODO: show progress bar
        self.load_settings()
        self.get_releases()
        # TODO: hide progress bar
        self.show_dialog()

    def get_releases(self):

        # Attempt to download things from github
        try:
            with contextlib.closing(urllib2.urlopen(urllib2.Request(REPO_URL + "/tags"), context=ssl._create_unverified_context())) as response:
                data = response.read()
                if data == "":
                    raise ValueError("Unable to get the release list")
        except:
            raise ValueError("Unable to connect to GitHub and download the Release List")
            return

        # Parse the data and filter out versions we don't care about
        j_data = json.loads(data.decode('utf-8'))
        for release in j_data:
            tag_name = release["name"]
            if tag_name.startswith("v"):
                # NOTE: we don't have a distinction between pre- and production releases
                self.releases.append(tag_name) # pre-releases
                self.production_releases.append(tag_name) # full releases


    def show_dialog(self):
        dialog = UpdateDialog(hou.ui.mainQtWindow(), self)
        dialog.show()

    def download_url(self, url):
        """
            Download the zip file from github
        :param url:
        :return:
        """
        print "download_url:", url
        filename = os.path.basename(url)
        local_path = os.path.join(HOU_TEMP_PATH, filename)
        print " - filename:", filename
        print " - local_path:", local_path

        if not os.path.exists(os.path.dirname(local_path)):
            os.makedirs(os.path.dirname(local_path))

        try:
            zipfile = urllib2.urlopen(url, context=ssl._create_unverified_context())
            print "zipfile:", zipfile
            with open(local_path, 'wb') as output:
                output.write(zipfile.read())
        except:
            raise ValueError("Unable to download the package file :" + url)
            return

        return local_path

    def get_download_path(self, version):
        """
            Get the asset list for the version and isolate which file we want (the Zip file)
            With some logic built in if they select older versions

        :param version:
        :return:
        """
        print "get_download_path()", version
        dl_path = REPO_DL_URL + "/" + version + ".zip"
        print "get_download_path()", dl_path
        return dl_path


    def unzip_file(self, zip_file, destination_path):
        zipf = zipfile.ZipFile(zip_file, 'r', zipfile.ZIP_DEFLATED)
        zipf.extractall(destination_path)

    def load_settings(self):
        print "trying to load settings from", str(SETTINGS_FILE)
        try:
            with open(SETTINGS_FILE, 'r') as fp:
                settings = json.load(fp)
                self.current_version = settings["current_version"]
        except:
            print "nah"
            self.current_version = None

    def store_settings(self):
        settings = {"current_version": self.desired_version, "current_branch": "Development"}
        with open(SETTINGS_FILE, 'w') as fp:
            json.dump(settings, fp)

    def show_success_dialog(self, mode):
        message = ""

        if mode == "change":
            message = "qLib Updated Successfully"
            message += "\n Please Restart Houdini to load all of the new tools"

        elif mode == "uninstall":
            message = "qLib Uninstalled Successfully"
            message += "\n Please Restart Houdini for changes to take effect"

        hou.ui.displayMessage(message, title="Success")

    def on_dialog_close(self, version, mode):
        """ Call back from the Updater Dialog """
        self.desired_version = version

        if mode == "change":
            download_url = self.get_download_path(version)
            if not download_url:
                hou.ui.displayMessage("Package not Available for this Version", severity=hou.severityType.Error)
                return

            # TODO: display progress bar here
            local_path = self.download_url(download_url)
            print "local path:", local_path
            self.unzip_file(local_path, os.path.join(HOU_TEMP_PATH, APP_VERSION))
            # NOTE: we don't add another folder like in the GameDevToolset
            # because we're downloading from "archive" and that comes with a folder already

            os.remove(local_path)

            self.patch_houdini_env(version, "change")
            self.store_settings()
            self.show_success_dialog("change")

        elif mode == "uninstall":
            # Patch ENV var
            self.patch_houdini_env(version, "uninstall")
            self.desired_version = None
            self.store_settings()

            # Delete Installed Files
            subdir = version.replace("v", "qLib-")
            removedir = os.path.join(HOU_TEMP_PATH, APP_VERSION, subdir)
            print "removedir:", removedir
            if os.path.exists(removedir):
                shutil.rmtree(removedir, ignore_errors=True)

            self.show_success_dialog("uninstall")

    def patch_houdini_env(self, version, mode):

        subdir = version.replace("v", "qLib-")

        filepath = HOUDINI_ENV
        if platform.system() == "Windows":
            sep = ";"
            quote_char = ""
        else:
            sep = ":"
            quote_char = "\""

        to_write = []

        with open(filepath, "r") as fp:
            skip_next_line = False
            skipped_lines = 0
            for line in fp.readlines():
                if skip_next_line:
                    skipped_lines += 1

                    if skipped_lines >= 1:
                        if "QLIB" in line:
                            continue
                        skip_next_line = False
                        skipped_lines = 0
                    #continue

                if "# QLIB (INSTALLER) " in line:
                    skip_next_line = True
                    continue

                to_write.append(line)

        if to_write[-1].strip() != "":
            to_write.append("\n")


        if mode == "change":
            to_write.append("# QLIB (INSTALLER) \n")

            # QLIB
            entry = "QLIB = "
            entry += quote_char + os.path.join(HOU_TEMP_PATH_STR, APP_VERSION, subdir) + quote_char + "\n"
            to_write.append(entry)

            # HOUDINI_OTLSCAN_PATH
            entry = "HOUDINI_OTLSCAN_PATH = "
            entry += quote_char
            entry += "$HOUDINI_OTLSCAN_PATH" + sep
            for section in ["base", "future", "experimental"]:
                entry += "$QLIB/otls/" + section + sep
            entry += "&" + quote_char + "\n"
            to_write.append(entry)

            # HOUDINI_PATH
            entry = "HOUDINI_PATH = "
            entry += quote_char + "$HOUDINI_PATH" + sep
            entry += "QLIB"
            entry += sep + "&" + quote_char + "\n"
            to_write.append(entry)


        with open(filepath, "w") as fp:
            for line in to_write:
                fp.write(line)

qLibUpdater()
]]></script>
  </tool>

  <tool name="qLib::ToggleViewportBackgroundColor" label="/backgnd/" icon="COP2_invert">
    <helpText><![CDATA[#icon: COP2/invert
#context: obj
#type: tool

= Cycle Viewport Background Color qL =

*version 1*

"""Cycles between viewport color schemes (dark, grey, light).
---
LMB: Cycle background color.
Ctrl-LMB: Reset to black.
Shift-LMB: Reset to grey.
"""

@bugs Limitations

- It might not seem to work for the first time (try clicking again, then)


@relnotes Release Notes

_version 1_ ---

2015-02-24:
    - Added dark/grey/light cycle (H14)

2014-02-14:
    - First version (in qLib).
]]></helpText>
    <script scriptType="python"><![CDATA[import toolutils

bg = None

try:
    # cycle next bg
    if kwargs['ctrlclick']: raise
    bgs = hou.session.bg[:]
    bgs = bgs[1:]+bgs[:1]
    if kwargs['shiftclick']: bgs = ['bw', 'light', 'wb']
    bg = bgs[0]
    hou.session.bg = bgs
except:
    # set up default bg vars
    hou.session.bg = ['wb', 'bw', 'light']
    bg = hou.session.bg[0]

bgs = { 'wb':'dark', 'bw':'grey', 'light':'light' }

hou.hscript("viewdisplay -B %s *" % bg)
hou.ui.setStatusMessage("Cycled background to %s" % bgs[bg].upper() )]]></script>
  </tool>

  <tool name="qLib::ToggleIntegerFrames" label="int.frames" icon="PLAYBAR_editable_keys">
    <helpText><![CDATA[#icon: PLAYBAR/editable_keys
#context: obj
#type: tool

= Toggle Integer Frames qL =

*version 1*

"""Toggle non-integer frame values on the playbar.
---
LMB: Toggle non-integer frames.
Shift-LMB: Switch to integer frames.
"""

@usage Usage

- ((LMB)):
    Toggle non-integer frames
- ((Shift + LMB)):
    Switch to integer frames


_version 1_ ---

2018-07-22:
    - Added shift-click option
    - Improved help page]]></helpText>
    <script scriptType="python"><![CDATA[import hou

shift = kwargs['shiftclick']

m = not hou.playbar.usesIntegerFrames()
if shift:
    m = True
hou.playbar.setUseIntegerFrames(m)

hou.ui.setStatusMessage(" ---- Using Integer Frames: %s" % ("ON" if m else "OFF"))
]]></script>
  </tool>

  <tool name="qLib::AttribDisplayMarkers" label="attr.vis" icon="BUTTONS_displayoptions">
    <helpText><![CDATA[#icon: BUTTONS/displayoptions
#context: obj
#type: tool

= Attrib Display Markers qL =

*version 1* (obsoleted by viewport visualizers)

"""Creates display markers for all the attributes present on the displayed operator.
---
Shift-LMB: Clear previously built.
Ctrl-LMB: Clear ALL markers then rebuild.
Ctrl+Shift-LMB: Clear ALL markers.
"""

This function builds visual display markers for all the attributes
that exist on the currently displayed operator.

(It can be considered as a shortcut to the similar function of the
[Attr Visualize qL SOP|node:sop/qLib::attr_visualize_ql::1]'s
_Marker_ section.)

@usage Usage

- ((LMB)):
    Builds attribute markers for the current Display SOP.
    (Existing markers will also be rebuilt.)
- ((Shift + LMB)):
    Clears previously built attribute markers.
    (Markers not built with this function will be preserved.)
- ((Ctrl + LMB)):
    Clears _all_ markers (made by this tool or otherwise)
    and rebuilds the attribute marker list.
- ((Ctrl + Shift + LMB)) . :
    Deletes _all_ display markers. _All of them._


@related
    - [Attr Visualize qL SOP|node:sop/qLib::attr_visualize_ql::1]
    - ...

@usage Using Add Display Markers

Set the Display flag on a node and click the shelf button. Then press
the `D` key in a Scene View, go to the Markers tab to see the generated
attribute markers ("Custom" section.)



]]></helpText>
    <script scriptType="python"><![CDATA[import hou
import toolutils


def ynreq(msg):
    return hou.ui.displayMessage(msg, ["Ok", "Cancel"]) == 0

def dispmsg(msg):
    hou.ui.setStatusMessage(msg)



def get_current_viewer_name():
    v = toolutils.sceneViewer()
    w = "%s.%s.world" % \
            (v.pane().desktop().name(), \
            v.name() )
    return w



def get_display_sop():
    v = None
    try:
        v = toolutils.sceneViewer()
        v = v.pwd() # OBJ object
        v = v.displayNode()
    except:
        v = None
        dispmsg("couldn't get Display (S)OP")
    return v



def clear_built_markers(kwargs=None, clearAll=False):
    if True: #ynreq("Clear %s display markers?" % "ALL" if clearAll else "generated"):
        for m in hou.hscript("viewoptls")[0].split():
            if clearAll or '_vis_' in m:
                print "viewoptrm %s" % m
                hou.hscript("viewoptrm %s" % m)





def build_markers(kwargs=None): # ( was create_markers() )
    """."""

    type_names = {
        hou.attribType.Point: "point",
        hou.attribType.Prim: "prim",
        hou.attribType.Vertex: "vertex"
    }

    type_labels = {
        hou.attribType.Point: "p:",
        hou.attribType.Prim: "pr:",
        hou.attribType.Vertex: "vt:"
    }

    pwd = get_display_sop()
    if pwd: dispmsg("display OP: %s" % pwd.path())
    else: return

    type_name  = lambda t: type_names[t]  if t in type_names  else ""
    type_label = lambda t: type_labels[t] if t in type_labels else ""
    p  = lambda n: pwd.parm(n).eval()
    ps = lambda n: pwd.parm(n).eval().strip()

    views = hou.hscript("viewls -n")[0].split()
    g = pwd.geometry()

    def to_as(attrs):
        return " ".join( [ a.name() for a in attrs if a.dataType() is not hou.attribData.String ] )

    #force_tx  = ps('force_text').split()
    #vel_attrs = ps('vel_attribs').split()

    force_tx = 'P Cd uv'.split()
    vel_attrs = 'v accel'.split()

    scale_v   = 1.0 # vec scale
    scale_vel = (1/24.0) # velocity scale

    attrs_pt = to_as(g.pointAttribs())
    attrs_pr = to_as(g.primAttribs())
    attrs_vtx = to_as(g.vertexAttribs())

    #attrs_display = ps('markers_display').split()
    #if p('do_markers_display')==0: attrs_display = []

    CS = [
            (attrs_pt, g.findPointAttrib),
            (attrs_pr, g.findPrimAttrib),
            (attrs_vtx, g.findVertexAttrib)
        ]

    hue = 120.0
    color = hou.Color()

    for C in CS:

        attrs = C[0].split()
        find_attr_func = C[1] #g.findPointAttrib

        # add textual version of vector attrs
        attrs += [ ("text:%s" % v) for v in attrs if find_attr_func(v).size()==3 ]
        attrs = sorted(attrs)

        for name in attrs:

            tx = "text:" in name
            name = name.replace("text:", "")

            a = find_attr_func(name)
            if a and a.dataType() is not hou.attribData.String:
                opt_name = "_vis_%s_%d" % (name, tx, )
                size = a.size()
                is_xn = a.isTransformedAsNormal()
                is_xv = a.isTransformedAsVector()
                is_vect = size==3 and not tx # and name not in force_tx
                as_vel = name in vel_attrs
                scale = scale_vel if as_vel else scale_v
    
                label = "%s%s" % ( type_label(a.type()), name )
    
                if is_vect:
                    label += " [vec."
                    if as_vel: label += "/v."
                    if is_xn: label += "; xformed as normal"
                    if is_xv: label += "; xformed as vector"
                    label += "]"
                else:
                    pass # label += " (num)"
    
                print "--- %s: '%s'" % (name, label)
    
                # create/update marker
    
                hou.hscript('viewoptrm %s' % opt_name)
                hou.hscript('viewoptadd %s %s' % ('vector' if is_vect else 'text', opt_name))
    
                def vos(parm, val):
                    print ' --- viewoptset %s %s ( %s )' % (opt_name, parm, val)
                    hou.hscript('viewoptset %s %s ( %s )' % (opt_name, parm, val))

                if True:    
                    vos('attrib', a.name())
                    vos('class', type_name(a.type()))
                    vos('label', '"%s"' % label)
                    vos('overridecolor', '1')

                    val = 0.85 if is_vect else 0.15

                    color.setHSV((hue, 0.9, val)); vos('color', '%f %f %f' % color.rgb())
                    color.setHSV((hue, 0.4, val+0.1)); vos('selcolor', '%f %f %f' % color.rgb())
                    hue += 137.5 * 0.5

                if is_vect:
                    vos('scale', scale)

                if False: # name in attrs_display:
                    for view in views:
                        hou.hscript('viewoptenable %s all +%s' % (view, opt_name))
                    hue += 137.5/2.0

            else:
                print "couldn't find attribute %s" % name

    print "done. ------------"

'''
viewoptset
    vector_dunno
        arrow ( 0 )
        attrib ( N )
        class ( point )
        color ( 0 0 1 )
        icon ( SI_pointNormal )
        label ( "pr: primN (vector)" )
        overridecolor ( 0 )
        scale ( 1 )
        selcolor ( 0 0.45 1 )
        visibility ( 1 )
'''


print kwargs

shift = kwargs['shiftclick']
ctrl  = kwargs['ctrlclick']
alt   = kwargs['altclick']

clear_built_markers(kwargs, clearAll=ctrl)

if not shift:
    build_markers(kwargs)
]]></script>
  </tool>

  <tool name="qLib::ReferenceCopy" label="Ref Copy qL" icon="BUTTONS_copy">
    <helpText><![CDATA[#icon: BUTTONS/copy
#context: obj
#type: tool

= Reference Copy qL =

*version 1*

"""Creates a Reference Copy where the reference source is easy to replace.
---
LMB: Create reference copy with a single link to the source node.
Alt-LMB: Use relative path for source node.
"""

This function is the same as the original _Reference Copy_ operation,
but it adds an extra parameter that specifies the source operator name
where all parameter values are referenced from.

This way the reference source is easy to change.


@usage Using Reference Copy

Select node(s) and click the shelf button.


@relnotes Release Notes

_version 1_ ---

2015-01-16:
    - Added workaround for "assets with editable subnets can't be reference copied" issue
      (works with qLib nodes only)

2014-04-05:
    - Added Alt+LMB mode (creates relative path for reference source)

2014-02-14:
    - Fixed serious bug (worked properly only on frame 1)
    - Uses `chsop()` now to get OP paths

2013-03-10:
    - First version.
]]></helpText>
    <script scriptType="python"><![CDATA[# do the dunno
#
import hou
import re

def postproc_refcopy(nodepath, srcpath):
    N = hou.node(nodepath)

    if N:

        # add ref_source parameter
        #
        N.addSpareParmTuple(
            hou.StringParmTemplate(
                "ref_source", "Ref Source", 1,
                string_type=hou.stringParmType.NodeReference
            )
        )

        N.parm('ref_source').set(srcpath)

        # process linkage expressions
        #
        parms = N.parms()
        for p in parms:
            try:
                if not p.parmTemplate().isHidden(): # skip hidden parms, e.g. description labels
                    for k in p.keyframes():
                        x = k.expression()
                        x = re.sub('"\.\./[^/]+', 'chsop("ref_source")+"', x)
                        k.setExpression(x, hou.exprLanguage.Hscript)
                        p.setKeyframe(k)

            except Exception as e:
                print "failed for param '%s'" % p.name()

        # store typename of the creator tool
        #
        hou.hscript("opuserdata -n '___toolcount___' -v '%s' %s" % ('1', nodepath, ))
        hou.hscript("opuserdata -n '___toolid___' -v '%s' %s" % ('ReferenceCopy_qL', nodepath, ))


def fixum(node, mode):
    '''Workaround for the "assets with editable subnets cannot be reference copied" issue.'''
    try:
        n = hou.node(node)
        t = n.type()
        d = t.definition()

        tn = t.name()
        # hackish workaround: apply to all qLib nodes
        #
        if 'qLib::' in tn and '_ql' in tn:
            #print "(applying %s to %s)" % (mode, n.path(), )

            if mode=='open':
                n.allowEditingOfContents()
                pass

            if mode=='close':
                n.matchCurrentDefinition()
                pass
        else:
            #print "(skipping %s)" % (n.path(), )
            pass
    except:
        print "oops #1"
        pass

# main
#
sel = [ n.path() for n in hou.selectedNodes() ]

alt = kwargs['shiftclick'] or kwargs['altclick'] or kwargs['ctrlclick']

for S in sel:
    c = len( hou.hscript( 'opls -d %s*' % S )[0].split() )
    T = '%s_copy%d' % (S, c)

    try:
        fixum(S, 'open') # "Allow Editing of Contents" for S
        hou.hscript('opcp -c %s %s' % (S, T))
        fixum(S, 'close') # "Match Current Definition" for S and T
        fixum(T, 'close')
    except:
        print "oops #2, %s" % S
        pass

    if True:
        srcpath = S
        if alt:
            srcpath = hou.node(T).relativePathTo(hou.node(S))
        postproc_refcopy(T, srcpath)

]]></script>
  </tool>

  <tool name="qLib::ToggleViewportTemplates" label="/templates/" icon="NODEFLAGS_template">
    <helpText><![CDATA[#icon: NODEFLAGS/template
#context: obj
#type: tool

= Toggle Viewport Templates qL =

*version 1*

"""Toggles template geometry display in viewports.
---
LMB: Toggle template display.
Shift-LMB: Enable template display.
Ctrl-LMB: Clear display template flag on all (S)OPs.
"""

@usage Usage

- ((LMB)):
    Toggles template display (Display Options -> Guides -> Templated geometry, Selectable templates)
- ((Shift + LMB)):
    Enable template display
- ((Ctrl + LMB)):
    Clears template flag on all (S)OPs within the currently displayed container


@related
    - ...

]]></helpText>
    <script scriptType="python"><![CDATA[import toolutils

shift = kwargs['shiftclick']
ctrl  = kwargs['ctrlclick']
alt   = kwargs['altclick']


if ctrl:
    n = toolutils.sceneViewer()
    n = n.pwd() # container node

    for c in n.children():
        try:
            c.setTemplateFlag(0)
            c.setSelectableTemplateFlag(0)
        except:
            pass

    hou.ui.setStatusMessage("Cleared all display template flags")
else:

    if not hasattr(hou.session, "templates"):
        hou.session.templates = True

    hou.session.templates = not hou.session.templates

    if shift: hou.session.templates = True

    t = 'on' if hou.session.templates else 'off'
    hou.hscript("viewdisplay -T %s -i %s *" % (t, t, ))
    hou.ui.setStatusMessage("Templates are now %s" % ("DISPLAYED" if hou.session.templates else "OFF") )
]]></script>
  </tool>

  <tool name="qLib::ToggleViewportGuides" label="/guides/" icon="NODEFLAGS_origin">
    <helpText><![CDATA[#icon: IMAGE/view_guides
#context: obj
#type: tool

= Toggle Viewport Guides qL =

*version 1*

"""Toggles OP guide display in the viewports.
---
LMB: Toggle guide display.
Shift-LMB: Enable guide display.
"""

@usage Usage

- ((LMB)):
    Toggles guides display (Display Options -> Guides -> Node guides)
- ((Shift + LMB)):
    Enable guides display

@bugs Limitations

- It might behave inconsistently between viewports (and needs to be clicked twice)


@relnotes Release Notes

_version 1_ ---

2018-07-22:
    - Added shift-click option
    - Improved help page

2014-03-20:
    - First version.
]]></helpText>
    <script scriptType="python"><![CDATA[import toolutils

shift = kwargs['shiftclick']

v = toolutils.sceneViewer()
w = "%s.%s.world" % \
        (v.pane().desktop().name(), \
        v.name() )
#print "view:", w

if not hasattr(hou.session, "guides"):
    hou.session.guides = True

if shift:
    hou.session.guides = False

hou.session.guides = not hou.session.guides
#hou.hscript("viewdisplay -g %s %s" % ("on" if hou.session.guides else "off", w, ))
hou.hscript("viewdisplay -g %s *" % ("on" if hou.session.guides else "off", ))
hou.ui.setStatusMessage("Geometry guides are now %s" % ("DISPLAYED" if hou.session.guides else "OFF") )]]></script>
  </tool>

  <tool name="qLib::CrashRecovery" label="::recover::" icon="MISC_satchel">
    <helpText><![CDATA[#icon: MISC/satchel
#type: tool

= Crash Recovery qL =

*version 1*

"""Opens the crash recovery window to load crash recovery hip files.
"""


]]></helpText>
    <script scriptType="python"><![CDATA[import qlibutils

qlibutils.do_crash_recovery()

]]></script>
  </tool>

  <tool name="qLib::camera_dolly_zoom_ql" label="dolly/zoom" icon="OBJ_camera">
    <helpText><![CDATA[#icon: OBJ/camera
#type: tool

= Camera Dolly/Zoom qL =

*version 1*

"""Switches to the dolly/zoom ('vertigo') camera viewport state (H17.5+).
---
LMB: Dolly/Zoom ("Vertigo").
MMB: Focal Length Zoom.
RMB: Dolly.
SPACE: Regular viewport navigation.
"""
]]></helpText>
    <script scriptType="python"><![CDATA[import qlibutils

v = qlibutils.houVersionAsFloat()

if v>=17.5:
    try:
        import stateutils
        viewer = stateutils.findSceneViewer()
        # this is: obj, sop, dop
        t = viewer.pwd().childTypeCategory().name().lower()[:3]
        type = "qLib::camera_zoom_vertigo_ql_%s" % t

        # do some proper checking if the state exists
        try:
            viewer.setCurrentState(type)
        except:
            pass
    except:
        pass
else:
    hou.ui.displayMessage("This requires Houdini 17.5 or higher")
]]></script>
  </tool>

  <tool name="qLib::ToggleTimeDependencyDisplay" label="/time dep/" icon="NETVIEW_time_dependent_badge_large">
    <helpText><![CDATA[#icon: NETVIEW/time_dependent_badge_large
#context: obj
#type: tool

= Toggle Time Dependency Display qL =

*version 1*

"""Toggles time dependency badge display in all network editors.
---
LMB: Toggle time dependency display (between normal and large).
Shift-LMB: Turn on (large).
Ctrl-LMB: Turn off (hide).
"""

@usage Usage

- ((LMB)):
    Toggle time dependency display
- ((Shift + LMB)):
    Turn on display
- ((Ctrl + LMB)):
    Turn off display

@bugs Limitations

- It's for H16.5 or higher (but should work in H16)


@relnotes Release Notes

_version 1_ ---

2018-07-22:
    - Added shift/ctrl-click functions

2018-05-27:
    - First version.
]]></helpText>
    <script scriptType="python"><![CDATA[# toggle time-dependency display in network editor(s)
# in H16.5 the relevant preference is called "badgetimedep", which can be set to "hide", "normal" or "large". "showtimedep" is no longer used

shift = kwargs['shiftclick']
ctrl  = kwargs['ctrlclick']

D = 'badgetimedep'
ns = [ t for t in hou.ui.paneTabs() if type(t) is hou.NetworkEditor ]

try:
    b = ns[0].getPref(D)
    b = 'normal' if b=='large' else 'large'
    
    if shift:
        b = 'large'
    if ctrl:
        b = 'hide'
    
    for n in ns:
        n.setPref('showtimedep', '1') # make it compatible w/ 16.0
        n.setPref(D, b) # use the 16.5+ way

except:
    hou.ui.setStatusMessage("Couldn't toggle time-dependency badge", hou.severityType.Warning)]]></script>
  </tool>

  <tool name="qLib::FlushCaches" label="flush caches" icon="SOP_cache">
    <helpText><![CDATA[#icon: SOP/cache
#type: tool

= Flush Caches qL =

*version 1*

"""Flush various memory caches and unloads all geometry.
"""


]]></helpText>
    <script scriptType="python"><![CDATA[
r = hou.ui.displayMessage(
        'Flush all caches? This is a non-undoable operation which might flush locked SOP geometry.',
        buttons=('Ok', 'Cancel',),
        default_choice=1, close_choice=1,
    )

if r==0:
    cmds = [
            "opunload -R /*",
            "geocache -c",
            "objcache -c",
            "sopcache -c",
            "texcache -c"
        ]

    for cmd in cmds:
        print " --- ", cmd
        hou.hscript(cmd)
]]></script>
  </tool>

  <tool name="qLib::ColorByAuthor" label="/color by author/" icon="COP2_mosaic">
    <helpText><![CDATA[#icon: SOP/color
#type: tool

= Color by Author qL =

*version 1*

"""Color nodes in a network based on their authors.
Select node(s) in the network editor to specify network.
---
LMB: Apply coloring by author.
Shift-LMB: Restore original colors (requires node selection!)
"""

Select node(s) in a network to specify network.
All nodes from the authors of selected nodes will he highlighted.

Use ((Shift + LMB)) to restore original colors.

NOTE:
    You still have to select a node to specify the network
    where colors need to be restored.

@usage Usage

- ((LMB)):
    Apply color by node author
- ((Shift + LMB)):
    Restore original node colors
]]></helpText>
    <script scriptType="python"><![CDATA[# color-code nodes based on author names
#

import toolutils
import colorsys
import re
import json

def restore_node_visu(node):
    '''Restore previous color (comment etc) on a node.'''

    has_data = lambda name: name in node.userDataDict()
    data = node.userData

    if has_data('color'):
        node.setColor(hou.Color(json.loads(data('color'))))
        node.destroyUserData('color')

    if has_data('comment'):
        node.setComment(data('comment'))
        node.destroyUserData('comment')

    if has_data('showcomment'):
        hou.hscript('opset -Y %s %s' % (data('showcomment'), node.path(), ))
        node.destroyUserData('showcomment')


def save_node_visu(node):
    '''Save (or resave) original node color/comment.'''
    restore_node_visu(node)
    # userData is string only so we just dump it as a json string
    node.setUserData('color', json.dumps(node.color().rgb()))
    node.setUserData('comment', node.comment())

    try:
        flags = hou.hscript('opset %s' % node.path())[0]
        flags = re.search('-Y [^ ]+', flags).group(0) # might throw here
        showcom = flags.replace('-Y ', '')
        node.setUserData('showcomment', showcom)
    except:
        pass # worst case, we're not storing this flag


def set_node_visu(node, color=None, comment=None):
    '''Set color/comment of a node. Should be used after visu is saved on a node.'''
    if color:
        node.setColor(hou.Color(color))
    if comment:
        node.setComment(comment)
        # turn on "show comment in network view"
        hou.hscript('opset -Y on %s' % node.path())



def get_node_author(node):
    '''Get name of author of a node.'''
    author = '???'
    try:
        # digging up author info from an archaic command
        author = hou.hscript('opstat -u %s' % node.path())[0].split(' ')[-1].split('\n')[0]
    except:
        pass # we can't hack the info out, just return '???'
    return author


# main function
#
restore_mode = kwargs['shiftclick']
sel = hou.selectedNodes()

nodeauths = {} # 'nodename': 'author' dict
authcolors = {} # 'author': color (3 floats tuple) dict
authors = set() # author names

if len(sel)>0:

    netw = sel[0].parent()
    hilite_authors = [ get_node_author(n) for n in sel ]
    
    # collect author names
    #
    for c in netw.children():
        a = get_node_author(c)
        authors.add(a)
        nodeauths[c.name()] = a
    
    authors = list(authors)
    
    # generate unique colors for authors
    #
    for i in range(len(authors)):
        author = authors[i]
        hue = float(i) / len(authors)
        val = 0.6 if i%2==0 else 0.5
        authcolors[author] = colorsys.hsv_to_rgb(hue, 0.5, val)

    # apply colors
    #
    func = restore_node_visu if restore_mode else save_node_visu
    for c in netw.children():
        func(c)

    if not restore_mode:
        for c in netw.children():
            author = nodeauths[c.name()]
            color = authcolors[author]
            set_node_visu(c, color=color, comment=author)
            if author in hilite_authors:
                c.setSelected(True)
else:
    hou.ui.setStatusMessage("Select node(s) to specify network to color (shift-click to restore)", hou.severityType.Warning)

#
]]></script>
  </tool>

  <tool name="rman_ris23" label="R23 ROP" icon="rm22_R_logo.svg">
    <script scriptType="python"><![CDATA[
import hou
import menutools
menutools.setIntegrator(None, "pxrpathtracer", search=True)
]]></script>
  </tool>

  <tool name="rman_ipron" label="IPR Render" icon="rm22_IPR.svg">
    <script scriptType="python"><![CDATA[
import hou
frame = hou.frame()
hasrop = False
for n in hou.node("/out").children():
    if n.type().nameComponents()[2] == "ris":
        output = n.parm("ri_ipr_device").eval()
        hasrop = True
        n.render(frame_range=(frame,frame), output_format=output, ignore_inputs=True)
        break

# if no ROP, create one
if not hasrop:
    ris_rop = hou.node("/out").createNode("ris")

    import menutools
    menutools.setIntegrator(ris_rop, "pxrpathtracer", search=True)

    output = ris_rop.parm("ri_ipr_device").eval()
    ris_rop.render(frame_range=(frame,frame), output_format=output, ignore_inputs=True)
]]></script>
  </tool>

  <tool name="rman_iproff" label="Stop Render" icon="rm22_IPR_Off.svg">
    <script scriptType="hscript"><![CDATA[rman_stop]]></script>
  </tool>

  <tool name="rman_spareparms" label="AddSpareParms" icon="rm22_addparms.svg">
    <script scriptType="python"><![CDATA[
import toolutils
import hou

scene_viewer = toolutils.sceneViewer()
targets = scene_viewer.selectObjects(
                prompt = toolutils.selectionPrompt(hou.objNodeTypeCategory()),
                allow_multisel = True)

vtuple = hou.applicationVersion()
rfhtree = hou.getenv("RFHTREE")
for target in targets:

    if target.type().name() == "geo":
        path = rfhtree + "/%d.%d/soho/parameters/geoparms.ds" % (vtuple[0], vtuple[1])
    elif target.type().name() == "cam":
        path = rfhtree + "/%d.%d/soho/parameters/camparms.ds" % (vtuple[0], vtuple[1])

    grp = target.parmTemplateGroup()
    spareparms = hou.ParmTemplateGroup()
    with open(path) as file:
        ds = file.read()
        spareparms.setToDialogScript(ds)
    for template in spareparms.parmTemplates():
        grp.append(template)

    try:
        target.parmsInFolder(("RenderMan",))
    except:
        target.setParmTemplateGroup(grp)

    if target.type().name() == "geo":
        hou.hscript("opproperty %s prman23geo *" % target.path())
    elif target.type().name() == "cam":
        hou.hscript("opproperty %s prman23cam *" % target.path())]]></script>
  </tool>

  <tool name="rman_holdout" label="Holdout" icon="rm22_holdOut.svg">
    <script scriptType="python"><![CDATA[
import hou

geos = []
rops = []

targets = hou.selectedNodes()
for target in targets:
    name_components = target.type().nameComponents()
    if name_components[2] == "geo":
        geos.append(target)
    elif name_components[2] == "ris":
        rops.append(target)

import menutools
menutools.createHoldout(rops, geos)]]></script>
  </tool>

  <tool name="rman_openit" label="Open IT" icon="rm22_it.svg">
    <script scriptType="python"><![CDATA[
import menutools
menutools.openIt()]]></script>
  </tool>

  <tool name="rman_pxrsurface" label="Surface" icon="VOP_PxrSurface.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrSurface</helpURL>
    <script scriptType="python"><![CDATA[
import menutools
menutools.createBxdf("pxrsurface")]]></script>
  </tool>

  <tool name="rman_pxrrectlight" label="Rect Light" icon="OBJ_pxrrectlight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrRectLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxrrectlight::22')]]></script>
  </tool>

  <tool name="rman_pxrdisklight" label="Disk Light" icon="OBJ_pxrdisklight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrDiskLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxrdisklight::22')]]></script>
  </tool>

  <tool name="rman_pxrspherelight" label="Sphere Light" icon="OBJ_pxrspherelight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrSphereLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxrspherelight::22')]]></script>
  </tool>

  <tool name="rman_pxrcylinderlight" label="Cylinder Light" icon="OBJ_pxrcylinderlight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrCylinderLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxrcylinderlight::22')]]></script>
  </tool>

  <tool name="rman_pxrmeshlight" label="Mesh Light" icon="OBJ_pxrmeshlight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrMeshLight</helpURL>
    <script scriptType="python"><![CDATA[
import menutools
menutools.createGeoLight(kwargs, "pxrmeshlight")]]></script>
  </tool>

  <tool name="rman_pxrvolumelight" label="Volume Light" icon="OBJ_PxrVolumeLight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrMeshLight</helpURL>
    <script scriptType="python"><![CDATA[
import menutools
menutools.createGeoLight(kwargs, "pxrvolumelight")]]></script>
  </tool>

  <tool name="rman_pxrdomelight" label="Dome Light" icon="OBJ_pxrdomelight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrDomeLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericTool(kwargs, 'pxrdomelight::22')]]></script>
  </tool>

  <tool name="rman_pxrportallight" label="Portal Light" icon="OBJ_pxrportallight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrPortalLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

portal = objecttoolutils.genericTool(kwargs, 'pxrportallight::22')]]></script>
  </tool>

  <tool name="rman_pxrenvdaylight" label="Env Day Light" icon="OBJ_pxrenvdaylight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrEnvDayLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericTool(kwargs, 'pxrenvdaylight::22')]]></script>
  </tool>

  <tool name="rman_pxrdistantlight" label="Distant Light" icon="OBJ_pxrdistantlight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrDistantLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxrdistantlight::22')]]></script>
  </tool>

  <tool name="rman_pxraovlight" label="AOV Light" icon="OBJ_pxraovlight.svg">
    <helpURL>https://rmanwiki.pixar.com/display/REN23/PxrAovLight</helpURL>
    <script scriptType="python"><![CDATA[import objecttoolutils

objecttoolutils.genericCameraLightTool(kwargs, 'pxraovlight::22')]]></script>
  </tool>
</shelfDocument>
